#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n <= 2) return 0;
        
        int left = 0, right = n - 1;
        int leftMax = 0, rightMax = 0;
        int result = 0;
        
        while (left <= right) {
            if (height[left] <= height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    result += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    result += rightMax - height[right];
                }
                right--;
            }
        }
        
        return result;
    }
};

int main() {
    Solution solution;
    
    // Test case 1
    vector<int> heights1 = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
    cout << "Test 1 - Expected: 6, Got: " << solution.trap(heights1) << endl;
    
    // Test case 2
    vector<int> heights2 = {4, 2, 0, 3, 2, 5};
    cout << "Test 2 - Expected: 9, Got: " << solution.trap(heights2) << endl;
    
    // Test case 3
    vector<int> heights3 = {3, 0, 2, 0, 4};
    cout << "Test 3 - Expected: 7, Got: " << solution.trap(heights3) << endl;
    
    return 0;
}
/////////////////////////////////////////////////
#inlcude <bits/stdc++.h>

int main(){
    int gifts;
    vector<int> scores;
    vector<int> gifts_vector;
    int len = scores.size();
    for(int i = 0; i < len; i++){
        gifts_vector.push_back(1);
    }
    for(int i = 0; i < len; i++){
        if(i == 0 && scores[i] > scores[i+1]){
            gifts_vector[i]++;
        }
        else if(i == len-1 && scores[i] > scores[i-1]){
            gifts_vector[i] += scores[i-1];
        }
        if(scores[i-1] < scores[i]){
            gifts_vector[i] += scores[i-1];
        }
        else if(scores[i] > scores[i+1]){
            gifts_vector[i] += 1;
        }
    }
}
//////////////////////////////////////////////////////////////////////////////
https://gist.github.com/SuhasDissa/003fc41d3a0a27f2152a09e1a51c1597
//////////////////////////////////////////////////////////////////////////////////////////////////
int evenForest(int t_nodes, int t_edges, vector<int> t_from, vector<int> t_to) {
    vector<vector<int>> tree(t_nodes + 1);
    vector<bool> visited(t_nodes + 1, false);
    int removableEdges = 0;

    // Build the undirected graph (tree)
    for (int i = 0; i < t_edges; ++i) {
        tree[t_from[i]].push_back(t_to[i]);
        tree[t_to[i]].push_back(t_from[i]);
    }

    // DFS function to calculate subtree sizes
    function<int(int)> dfs = [&](int node) {
        visited[node] = true;
        int subtree_size = 1; // count the node itself

        for (int neighbor : tree[node]) {
            if (!visited[neighbor]) {
                int child_subtree_size = dfs(neighbor);
                if (child_subtree_size % 2 == 0) {
                    // If child subtree has even number of nodes, we can cut the edge
                    ++removableEdges;
                } else {
                    subtree_size += child_subtree_size;
                }
            }
        }

        return subtree_size;
    };
//////////////////////////////////////////////////////////////////////////////////////////////////

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <sstream>
#include <algorithm>
using namespace std;

int process(vector<int> nums,int search, int p, int r){
    
    if(r < p){
        return -1;
    }
    int q = (p+r)/2;
    if(search == nums[q]){
        return q;
    }
    if(nums[p] < nums[q]){
        if(nums[p] <= search && search <= nums[q-1]){
            return process(nums, search, p, q-1);
        }
        else{
            return process(nums, search, q+1, r);
        }
    }
    if(nums[q] < nums[r]){
        if(nums[q+1] <= search && search <= nums[r]){
            return process(nums, search, q+1, r);      
        }
        else{
            return process(nums, search, p, q-1);
        }
    }
    return -1;
}
int main() {
    string line;
    getline(cin, line);
    stringstream ss(line);
    string num;
    vector<int> nums;
    
    while(getline(ss, num, ',')){
        nums.push_back(stoi(num));
    }
    int size = nums.size();
    int search;
    cin>>search;
    cout<<process(nums,search, 0, size-1)<<endl;
    return 0;
}


    dfs(1); // assuming 1 is the root

    return removableEdges;
}
//////////////////////////////////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>
#include <string>

using namespace std;

int leastInterval(vector<char>& tasks, int n) {
    unordered_map<char, int> freq;
    for (char task : tasks) freq[task]++;
    
    // Max heap based on task frequency
    priority_queue<int> pq;
    for (auto& pair : freq) pq.push(pair.second);
    
    queue<pair<int, int>> cooldown; // (task count left, time it can re-enter)
    int time = 0;
    
    while (!pq.empty() || !cooldown.empty()) {
        time++;
        
        // Ready to push task back to heap
        if (!cooldown.empty() && cooldown.front().second == time) {
            pq.push(cooldown.front().first);
            cooldown.pop();
        }

        if (!pq.empty()) {
            int count = pq.top();
            pq.pop();
            if (count > 1) {
                cooldown.push({count - 1, time + n + 1});
            }
        }
        // else: idle step
    }
    
    return time;
}

int main() {
    vector<char> tasks;
    int n;
    
    string input;
    getline(cin, input); // Read the array of tasks like ['A','B',...]
    
    // Clean input string
    input.erase(remove(input.begin(), input.end(), '['), input.end());
    input.erase(remove(input.begin(), input.end(), ']'), input.end());
    input.erase(remove(input.begin(), input.end(), '\''), input.end());
    input.erase(remove(input.begin(), input.end(), '"'), input.end());
    input.erase(remove(input.begin(), input.end(), ' '), input.end());
    
    // Parse input
    size_t pos = 0;
    while ((pos = input.find(',')) != string::npos) {
        tasks.push_back(input.substr(0, pos)[0]);
        input.erase(0, pos + 1);
    }
    if (!input.empty()) tasks.push_back(input[0]);

    cin >> n;
    cout << leastInterval(tasks, n) << endl;

    return 0;
}
